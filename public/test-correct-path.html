<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper Model - Correct Path Resolution</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        .log { margin: 5px 0; padding: 5px; background: #000; }
        .error { color: #f00; }
        .success { color: #0f0; }
        .info { color: #ff0; }
    </style>
</head>
<body>
    <h1>Testing Correct Model Path Resolution</h1>
    <div id="output"></div>
    
    <script type="module">
        const output = document.getElementById('output');
        
        function log(msg, className = 'log') {
            const div = document.createElement('div');
            div.className = className;
            div.textContent = msg;
            output.appendChild(div);
            console.log(msg);
        }
        
        // Override fetch to monitor requests
        const originalFetch = window.fetch;
        window.fetch = async function(url, ...args) {
            // Log all model file requests
            if (url.includes('whisper') || url.includes('models')) {
                log(`üì° Fetching: ${url}`, 'info');
            }
            
            const response = await originalFetch(url, ...args);
            
            // Check if we got HTML instead of expected file
            if (response.headers.get('content-type')?.includes('text/html') && 
                (url.includes('.json') || url.includes('.onnx'))) {
                log(`‚ùå Got HTML for: ${url}`, 'error');
                const text = await response.clone().text();
                if (text.includes('<!doctype') || text.includes('<!DOCTYPE')) {
                    log('   ‚Üí This is the 404/index page, not the model file!', 'error');
                }
            }
            
            return response;
        };
        
        async function testConfigurations() {
            log('=== Testing Different Path Configurations ===', 'success');
            
            // Test 1: Check if files are accessible
            log('\n1. Direct file access test:', 'info');
            const testFiles = [
                '/models/whisper-tiny/config.json',
                '/models/whisper-tiny/tokenizer.json',
                '/models/whisper-tiny/preprocessor_config.json'
            ];
            
            for (const file of testFiles) {
                try {
                    const res = await fetch(file);
                    if (res.ok) {
                        log(`‚úì ${file} - Status: ${res.status}`, 'success');
                    } else {
                        log(`‚úó ${file} - Status: ${res.status}`, 'error');
                    }
                } catch (e) {
                    log(`‚úó ${file} - Error: ${e.message}`, 'error');
                }
            }
            
            // Test 2: Try loading with transformers
            log('\n2. Loading with @xenova/transformers:', 'info');
            
            try {
                const { pipeline, env } = await import('@xenova/transformers');
                
                // Configuration that should work with local files
                env.allowLocalModels = true;
                env.allowRemoteModels = false;
                env.localModelPath = '/models/';  // This should prepend to model name
                env.useBrowserCache = false;
                
                log('Configuration set:', 'info');
                log(`  allowLocalModels: ${env.allowLocalModels}`, 'info');
                log(`  allowRemoteModels: ${env.allowRemoteModels}`, 'info');
                log(`  localModelPath: ${env.localModelPath}`, 'info');
                
                log('\nAttempting to load pipeline...', 'info');
                
                // The model name should just be the folder name when using localModelPath
                const transcriber = await pipeline(
                    'automatic-speech-recognition',
                    'whisper-tiny',  // This should resolve to /models/whisper-tiny/
                    {
                        progress_callback: (progress) => {
                            if (progress.status === 'ready') {
                                log(`‚úì ${progress.file || 'Model'} ready`, 'success');
                            } else if (progress.status === 'progress') {
                                log(`‚è≥ Loading: ${progress.file} (${Math.round((progress.loaded/progress.total)*100)}%)`, 'info');
                            } else if (progress.status) {
                                log(`üì¶ ${progress.status}: ${progress.file || ''}`, 'info');
                            }
                        }
                    }
                );
                
                log('\nüéâ SUCCESS! Model loaded!', 'success');
                window.transcriber = transcriber;
                log('Model is available as window.transcriber', 'info');
                
            } catch (error) {
                log(`\n‚ùå Error: ${error.message}`, 'error');
                
                // Analyze the error
                if (error.message.includes('not found locally')) {
                    log('\nüìã Diagnosis:', 'info');
                    log('The error suggests the library is looking for files at the wrong path.', 'info');
                    log('Expected behavior: localModelPath + model name = full path', 'info');
                    log('So "/models/" + "whisper-tiny" should give "/models/whisper-tiny/"', 'info');
                    
                    // Extract the path it's actually looking for from the error
                    const match = error.message.match(/at "([^"]+)"/);
                    if (match) {
                        log(`\nActual path being checked: ${match[1]}`, 'error');
                        log('This suggests the library might be constructing paths incorrectly.', 'info');
                    }
                }
            }
        }
        
        // Run the test
        testConfigurations();
    </script>
</body>
</html>